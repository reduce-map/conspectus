# Алгоритміка: Основи

- [Data Structures and Algorithms in JavaScript, big respect to trekhleb](https://github.com/trekhleb/javascript-algorithms)
    - [Data Structures](https://github.com/trekhleb/javascript-algorithms?tab=readme-ov-file#data-structures)
    - [Algorithms](https://github.com/trekhleb/javascript-algorithms?tab=readme-ov-file#algorithms)

- **O(1)**: Константний час - алгоритм виконується за фіксований час, незалежно від розміру вхідних даних.
    - *Приклад*: Доступ до елемента масиву за індексом.
    - *Пояснення*: Оскільки масив має прямий доступ до своїх елементів, доступ до будь-якого елемента за індексом завжди займе однаковий час.

- **O(log n)**: Логарифмічний час - час виконання зростає логарифмічно зі збільшенням розміру вхідних даних.
    - *Приклад*: Бінарний пошук.
    - *Пояснення*: У бінарному пошуку з кожним кроком розмір проблеми зменшується вдвічі, тому загальна кількість кроків залежить від логарифму розміру вхідних даних.

- **O(n)**: Лінійний час - час виконання зростає лінійно зі збільшенням розміру вхідних даних.
    - *Приклад*: Проходження по масиву.
    - *Пояснення*: Кожен елемент масиву перевіряється один раз, тому час виконання прямо пропорційний кількості елементів.

- **O(n log n)**: Лінійно-логарифмічний час - час виконання збільшується лінійно-логарифмічно з ростом розміру вхідних даних.
    - *Приклади*: Сортування злиттям, швидка сортування.
    - *Пояснення*: Ці алгоритми поєднують лінійні проходження з логарифмічним зменшенням проблеми, використовуючи поділ і завоювання.

- **O(n^2)**: Квадратичний час - час виконання збільшується пропорційно до квадрату розміру вхідних даних.
    - *Приклад*: Сортування бульбашкою.
    - *Пояснення*: Кожен елемент порівнюється з кожним іншим, тому кількість порівнянь є квадратичною відносно кількості елементів.

- **O(n^3)**: Кубічний час - час виконання збільшується пропорційно до куба розміру вхідних даних.
    - *Приклад*: Алгоритм Флойда для знаходження всіх найкоротших шляхів.
    - *Пояснення*: Алгоритм перевіряє всі можливі пари вершин, і для кожної пари виконує перевірку через всі інші вершини.

- **O(n^k)**: Поліноміальний час - час виконання збільшується як поліном степені \(k\) від розміру вхідних даних.
    - *Приклад*: Алгоритми обробки графів.
    - *Пояснення*: Залежно від складності графу і операцій, час може бути різним, але загалом зростає поліноміально.

- **O(2^n)**: Експоненціальний час - час виконання збільшується експоненційно зі збільшенням розміру вхідних даних.
    - *Приклад*: Алгоритми рішення задач методом грубої сили.
    - *Пояснення*: Кількість можливих конфігурацій зростає експоненційно, що вимагає перебору великої кількості варіантів.

- **O(n!)**: Факторіальний час - час виконання збільшується пропорційно до факторіалу розміру вхідних даних.
    - *Приклад*: Повний перебір перестановок.
    - *Пояснення*: Кількість всіх можливих перестановок з \(n\) елементів є \(n!\), тому алгоритми, що вимагають перебору всіх перестановок, виконуються за факторіальний час.
