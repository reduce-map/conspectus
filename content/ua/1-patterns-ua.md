# Базові Патерни

## 1. GRASP Patterns (Принципи розподілу відповідальності)

- **Information Expert (Інформаційний експерт):** Відповідальність призначається тому класу, який має необхідну інформацію для виконання завдання.
- **Creator (Створювач):** Клас, який агрегує або керує іншими об'єктами, відповідає за їх створення.
- **Controller (Контролер):** Виступає посередником між користувачем і системою, обробляючи запити та координуючи дії інших об'єктів.
- **Low Coupling (Низьке зв'язування):** Зменшує залежності між класами, щоб полегшити зміни та підвищити стійкість коду.
- **High Cohesion (Висока зв'язність):** Кожен клас повинен бути сфокусований на виконанні однієї задачі, що спрощує розуміння та підтримку системи.
- **Polymorphism (Поліморфізм):** Використовує спільний інтерфейс для обробки альтернативних поведінкових варіантів на основі типу об'єкта.
- **Pure Fabrication (Чиста вигадка):** Створює допоміжний клас, який не є частиною предметної області, але вирішує конкретну архітектурну проблему.
- **Indirection (Посередник):** Вводить проміжний об'єкт, щоб зменшити зв'язок між іншими об'єктами.
- **Protected Variations (Захищені варіації):** Виявляє потенційні точки змін у системі та захищає їх через використання абстракцій.

## 2. Design Patterns Gang of Four (GoF) (Патерни Проектування від "Групи Чотирьох")

### Creational Patterns (Породжуючі Патерни)

- **Factory Method (Фабричний метод):** Визначає інтерфейс для створення об'єкта, але дозволяє підкласам змінювати тип створюваних об'єктів.
- **Abstract Factory (Абстрактна фабрика):** Надає інтерфейс для створення родин пов'язаних або залежних об'єктів без вказівки їх конкретних класів.
- **Builder (Будівельник):** Відокремлює конструювання складного об'єкта від його представлення, дозволяючи використовувати один і той самий процес конструювання для створення різних представлень.
- **Prototype (Прототип):** Визначає типи об'єктів для створення за допомогою прототипного екземпляра і створює нові об'єкти шляхом копіювання цього прототипу.
- **Singleton (Одинак):** Гарантує, що у класу є тільки один екземпляр, і надає глобальну точку доступу до нього.
- **Object Pool (Пул об'єктів):** Управляє пулом багаторазово використовуваних об'єктів, дозволяючи повторно використовувати ресурсоємні ресурси і обмежуючи кількість створюваних екземплярів.

### Structural Patterns (Структурні Патерни)

- **Adapter (Адаптер):** Перетворює інтерфейс класу в інший інтерфейс, який очікує клієнт. Адаптер дозволяє класам працювати разом, що неможливо через несумісність інтерфейсів.
- **Decorator (Декоратор):** Додає додаткові обов'язки об'єкту динамічно. Декоратори надають гнучку альтернативу для розширення функціональності без використання успадкування.
- **Composite (Компоновщик):** Об'єднує об'єкти в деревовидні структури для представлення ієрархії "частина-ціле". Компоновщик дозволяє клієнтам однаково працювати з окремими об'єктами та їхніми композиціями.
- **Bridge (Міст):** Відокремлює абстракцію від її реалізації, щоб обидві могли змінюватися незалежно.
- **Flyweight (Приспособленець):** Використовує спільне використання для підтримки великої кількості дрібнозернистих об'єктів ефективно.
- **Facade (Фасад):** Надає уніфікований інтерфейс до набору інтерфейсів у підсистемі. Фасад визначає інтерфейс більш високого рівня, що полегшує використання підсистеми.

### Behavioral Patterns (Поведінкові Патерни)

- **Chain of Responsibility (Ланцюг відповідальності):** Передає запит по ланцюгу обробників. При отриманні запиту кожен обробник або обробляє запит, або передає його наступному обробнику в ланцюгу.
- **Command (Команда):** Інкапсулює запит у вигляді об'єкта, що дозволяє параметризувати клієнтів чергами, запитами та операціями.
- **Interpreter (Інтерпретатор):** Визначає подання граматики для мови разом з інтерпретатором, який використовує це подання для інтерпретації виразів цієї мови.
- **Iterator (Ітератор):** Надає спосіб послідовного доступу до елементів агрегатного об'єкта без розкриття його внутрішнього подання.
- **Mediator (Посередник):** Визначає об'єкт, який інкапсулює спосіб взаємодії множини об'єктів. Посередник сприяє слабкій зв'язності, утримуючи об'єкти від явних посилань один на одного.
- **Memento (Хранитель):** Без порушення інкапсуляції, захоплює і зовнішньо відображає внутрішній стан об'єкта, щоб об'єкт можна було відновити до цього стану пізніше.
- **Observer (Спостерігач):** Визначає залежність типу "один до багатьох" між об'єктами, так що коли один об'єкт змінює стан, всі його залежні отримують повідомлення і автоматично оновлюються.
- **State (Стан):** Дозволяє об'єкту змінювати поведінку при зміні його внутрішнього стану. Об'єкт буде виглядати так, ніби він змінив свій клас.
- **Strategy (Стратегія):** Визначає сімейство алгоритмів, інкапсулює кожен з них і робить їх взаємозамінними.
- **Template Method (Шаблонний метод):** Визначає скелет алгоритму в методі, відкладаючи деякі кроки на підкласи.
- **Visitor (Відвідувач):** Представляє операцію, що виконується над елементами об'єктної структури. Відвідувач дозволяє визначати нові операції, не змінюючи класи елементів, над якими ці операції виконуються.

## 3. Enterprise Integration Patterns (Патерни Інтеграції Підприємства)

- **Message Channel (Канал Повідомлень):** Створює канал для зв'язку між системами, дозволяючи обмінюватися повідомленнями.
- **Message Endpoint (Кінцева Точка Повідомлень):** Визначає інтерфейс для відправлення та отримання повідомлень у межах корпоративної системи.
- **Message Router (Маршрутизатор Повідомлень):** Направляє повідомлення на різні канали залежно від конкретних умов або змісту повідомлення.
- **Message Translator (Перекладач Повідомлень):** Перетворює повідомлення з одного формату в інший, щоб забезпечити сумісність між різними системами.
- **Message Broker (Брокер Повідомлень):** Діє як посередник, який маршрутизує, трансформує та обробляє повідомлення між системами.
- **Message Filter (Фільтр Повідомлень):** Фільтрує повідомлення на основі певних критеріїв перед тим, як дозволити їм пройти на наступний етап.
- **Aggregator (Агрегатор):** Збирає пов'язані повідомлення і об'єднує їх в одне повідомлення перед обробкою.
- **Splitter (Розподілювач):** Розбиває одне повідомлення на декілька менших повідомлень для окремої обробки.
- **Content Enricher (Збагачувач Змісту):** Додає додаткові дані до повідомлення для підвищення його інформаційного змісту перед обробкою.

## 4. Архітектурні Патерни

- **Багатошарова архітектура (Layered Architecture):** Поділяє систему на шари з різними відповідальностями (наприклад, презентація, бізнес-логіка, доступ до даних) для покращення модульності та підтримуваності.
- **Архітектура мікросервісів (Microservices Architecture):** Структурує додаток як набір малих, автономних сервісів, що взаємодіють через мережу.
- **Архітектура, керована подіями (Event-Driven Architecture):** Використовує події як центральний механізм для комунікації між сервісами або компонентами, сприяючи слабкому зв'язку між ними.
- **Сервісно-орієнтована архітектура (Service-Oriented Architecture, SOA):** Організовує систему у вигляді сервісів, що надають багаторазово використовувані функції, доступні через мережу.
- **Монолітна архітектура (Monolithic Architecture):** Об'єднує всі функціональні можливості додатка в єдину кодову базу та розгортальну одиницю.
- **Клієнт-серверна архітектура (Client-Server Architecture):** Поділяє систему на компоненти клієнта та сервера, де клієнти запитують послуги, а сервери їх надають.
- **Модель-Вид-Контролер (MVC, Model-View-Controller):** Відокремлює логіку додатка, інтерфейс користувача та управління введенням у три взаємопов'язані компоненти для покращення модульності та гнучкості.
- **Шестикутна архітектура (Hexagonal Architecture, Ports and Adapters):** Ізолює основну логіку системи від зовнішніх систем та технологій, що полегшує їх зміну або заміну.

## 5. Патерни Конкурентності

- **Пул потоків (Thread Pool):** Керує пулом робочих потоків, які можуть бути використані повторно для виконання завдань, знижуючи накладні витрати на створення та управління потоками.
- **Блокування (Locking):** Забезпечує механізми, які гарантують, що лише один потік може отримати доступ до певних ресурсів одночасно, запобігаючи гонитві станів.
- **Монітор об'єктів (Monitor Object):** Синхронізує доступ до об'єкта таким чином, що лише один потік може виконувати критичну секцію коду одночасно.
- **Активний об'єкт (Active Object):** Розділяє виконання методу від виклику методу, щоб підвищити паралельне виконання та контроль за синхронізацією.
- **Розділення/Злиття (Fork/Join):** Розбиває завдання на менші підзадачі, які можуть виконуватися паралельно, а потім об'єднує їх результати.
- **Планувальник (Scheduler):** Керує виконанням завдань, плануючи їх запуск у певний час або у відповідь на певні події.
- **Виробник-Споживач (Producer-Consumer):** Синхронізує роботу потоків виробника, які генерують дані, та потоків споживача, які обробляють ці дані, використовуючи спільний буфер.
- **Незмінний об'єкт (Immutable Object):** Визначає об'єкти, стан яких не може бути змінений після створення, забезпечуючи безпеку потоків без синхронізації.

## 6. Реактивні Патерни

- **Спостерігач (Observer):** Встановлює механізм підписки, щоб дозволити об'єктам автоматично отримувати повідомлення при зміні стану іншого об'єкта.
- **Зберігання подій (Event Sourcing):** Фіксує всі зміни стану додатка у вигляді послідовності подій, які можуть бути відтворені для відновлення або аналізу стану.
- **Зворотний тиск (Backpressure):** Керує потоком даних між компонентами, щоб запобігти перевантаженню повільніших компонентів надмірною кількістю даних.
- **Переривник ланцюга (Circuit Breaker):** Моніторить взаємодію між сервісами та тимчасово зупиняє їх, щоб запобігти каскадним збоям, коли один сервіс стає недоступним.
- **Публікатор-Підписник (Publisher-Subscriber):** Дозволяє кільком підписникам отримувати події від одного публікатора без необхідності публікатору знати про підписників.
- **Реактивні потоки (Reactive Streams):** Визначає стандарт для асинхронної обробки потоків з неблокуючим зворотним тиском.
- **Обмін повідомленнями (Message Passing):** Полегшує комунікацію між компонентами або сервісами через відправку повідомлень замість прямого виклику методів.
- **Асинхронне обмін повідомленнями (Asynchronous Messaging):** Відокремлює відправлення та отримання повідомлень у часі, дозволяючи більш гнучку та стійку комунікацію.

## 7. Патерни Безпеки

- **Аутентифікація (Authentication):** Забезпечує правильну ідентифікацію користувачів або систем перед наданням доступу.
- **Авторизація (Authorization):** Керує дозволами, забезпечуючи, щоб користувачі могли виконувати лише ті дії, на які вони мають право.
- **Список контролю доступу (Access Control List, ACL):** Визначає, яким користувачам або системним процесам надано доступ до об'єктів і які операції дозволені.
- **Безпечне управління сесіями (Secure Session Management):** Підтримує та захищає користувацькі сесії, забезпечуючи, що дані сесій не будуть перехоплені або викрадені.
- **Шифрування (Encryption):** Захищає дані шляхом перетворення їх у безпечний формат, який може бути прочитаний лише уповноваженими сторонами.
- **Система виявлення вторгнень (Intrusion Detection System, IDS):** Моніторить та аналізує активність системи для виявлення та сповіщення про можливі порушення безпеки.
- **Брандмауер (Firewall):** Контролює потік мережевого трафіку на основі заздалегідь визначених правил безпеки, захищаючи систему від несанкціонованого доступу.
- **Токен безпеки (Security Token):** Представляє облікові дані користувача або іншу конфіденційну інформацію в захищеному, верифікованому форматі, який може бути використаний для аутентифікації та авторизації доступу.
- **Єдиний вхід (Single Sign-On, SSO):** Дозволяє користувачам автентифікуватися один раз і отримувати доступ до декількох пов'язаних систем без необхідності повторного входу.
- **Аудиторський слід (Audit Trail):** Зберігає запис про активність і доступ до системи для забезпечення відповідальності та відстеження дій, виконаних у системі.

## 8. Патерни Розподілених Систем

- **Вибір лідера (Leader Election):** Забезпечує, щоб один вузол у розподіленій системі був обраний як лідер для координації завдань і управління ресурсами.
- **Реплікація (Replication):** Дублює дані або сервіси на декілька вузлів для забезпечення доступності та стійкості до збоїв.
- **Шардинг (Sharding):** Розбиває дані на декілька баз даних або вузлів для покращення продуктивності та керованості.
- **Консенсус (Consensus):** Забезпечує, що всі вузли у розподіленій системі погоджуються на певний стан або значення, що зазвичай використовується у розподілених базах даних або технології блокчейн.
- **Кворум (Quorum):** Вимагає, щоб більшість вузлів погодили рішення перед його фіналізацією, що підвищує узгодженість та надійність операцій.
- **Консистентність даних (Data Consistency):** Забезпечує, що дані залишаються узгодженими на всіх розподілених вузлах, навіть у разі збоїв або одночасних оновлень.
- **Зрештою консистентність (Eventual Consistency):** Дозволяє тимчасові невідповідності даних на різних вузлах, з гарантією того, що всі вузли зрештою узгодяться.
- **Розподілені транзакції (Distributed Transactions):** Керує транзакціями на кількох вузлах, забезпечуючи атомарність і консистентність у розподілених середовищах.
- **Відкриття сервісів (Service Discovery):** Дозволяє динамічне виявлення сервісів у розподіленій системі, дозволяючи вузлам знаходити і підключатися один до одного без попередніх знань.

## 9. Патерни Мікросервісів

- **Реєстр сервісів (Service Registry):** Централізований каталог, де всі мікросервіси реєструються при запуску, і де клієнти можуть динамічно знаходити та підключатися до доступних сервісів.
- **API-шлюз (API Gateway):** Єдина точка входу для всіх клієнтських запитів до мікросервісів. Він обробляє завдання, такі як маршрутизація запитів, балансування навантаження, аутентифікація, обмеження швидкості та моніторинг. Також може надавати уніфікований інтерфейс до різних мікросервісів.
- **Переривник ланцюга (Circuit Breaker):** Захищає мікросервіси від каскадних збоїв, виявляючи, коли сервіс, ймовірно, зазнає невдачі, і тимчасово зупиняючи запити до цього сервісу, доки він не відновиться.
- **Сага (Saga):** Керує розподіленими транзакціями в архітектурі мікросервісів, координуючи серію локальних транзакцій. Якщо один з кроків не вдається, сага виконає компенсуючі транзакції, щоб анулювати роботу, виконану попередніми кроками.
- **CQRS (Command Query Responsibility Segregation):** Розділяє методи для читання і запису даних. Цей патерн дозволяє оптимізувати операції читання і запису, а також покращити масштабованість, особливо корисний в системах, де операції читання і запису мають дуже різні вимоги до продуктивності.
- **Сервісна сітка (Service Mesh):** Інфраструктурний шар для управління комунікацією між сервісами. Вона надає такі функції, як балансування навантаження, відкриття сервісів, управління трафіком і безпека (наприклад, взаємний TLS), абстрагуючи ці завдання від бізнес-логіки.
- **Сайдкар (Sidecar):** Сервіс-компаньйон, який запускається разом з основним сервісом у межах одного розгортального блоку (наприклад, Docker-контейнера). Сайдкар часто займається інфраструктурними завданнями, такими як логування, моніторинг або проксіювання запитів, дозволяючи основному сервісу зосередитися виключно на бізнес-логіці.
- **Перевірка здоров'я (Health Check):** Регулярно моніторить стан мікросервісів, щоб переконатися, що вони працюють належним чином. Якщо сервіс нездоровий, його можна перезапустити або перенаправити трафік на здоровий екземпляр.
- **Розподілене трасування (Distributed Tracing):** Відстежує запити, коли вони проходять через кілька мікросервісів, надаючи видимість у потік і продуктивність запитів і допомагаючи діагностувати проблеми з затримками або збоями.
- **Перемичка (Bulkhead):** Ізолює різні частини системи, щоб запобігти каскадному збою в одній частині системи. Кожен сервіс ізольований, щоб у разі збою однієї частини інші могли продовжувати функціонувати.
- **Бекенди для фронтендів (Backends for Frontends, BFF):** Створює унікальний API-шлюз або бекенд-сервіс для кожного типу клієнтів (наприклад, веб, мобільний). Цей патерн допомагає налаштувати бекенд-сервіси відповідно до потреб різних фронтендів, покращуючи продуктивність та користувацький досвід.
- **Зберігання подій (Event Sourcing):** Зберігає стан системи у вигляді послідовності подій. Замість збереження поточного стану, кожна зміна фіксується як подія, що дозволяє системі відновити стан шляхом відтворення цих подій. Це особливо корисно в мікросервісах для забезпечення узгодженості між сервісами.
- **Командна та подієво-керована комунікація (Command and Event-Driven Communication):** Використовує команди для ініціації процесу та події для сповіщення інших сервісів про зміни або завершення. Цей патерн підтримує асинхронну обробку і роз'єднує сервіси, покращуючи масштабованість і надійність.
- **База даних для кожного сервісу (Database per Service):** Забезпечує, щоб кожен мікросервіс керував своєю власною базою даних. Цей патерн забезпечує сильну інкапсуляцію і незалежність, дозволяючи сервісам розгортатися, масштабуватися і керуватися окремо.
- **Стратегія "удушення" (Strangler Fig):** Поступово замінює частини монолітної системи мікросервісами. Існуючий монолітний додаток рефакториться, і нова функціональність будується як мікросервіси, зрештою "удушаючи" стару систему, доки вона не буде повністю замінена.
- **Декомпозиція за піддоменом (Decomposition by Subdomain):** Розбиває систему на мікросервіси на основі меж контекстів або піддоменів, визначених у предметно-орієнтованому дизайні (DDD). Кожен мікросервіс відповідає за певну бізнес-функцію.
- **Зовнішнє налаштування (Externalized Configuration):** Зберігає налаштування конфігурації поза межами коду додатку, зазвичай у централізованій конфігураційній службі. Це дозволяє легко оновлювати конфігурації та забезпечувати узгодженість між мікросервісами, особливо під час розгортання та масштабування.
- **Синьо-зелене розгортання (Blue-Green Deployment):** Розгортає нову версію сервісу поруч зі старою, дозволяючи швидко відкотити зміни, якщо виникають проблеми. "Синє" середовище є поточною живою системою, а "зелене" - новою версією, що тестується.
- **Канарське розгортання (Canary Release):** Поступово розгортає нову версію мікросервісу на невелику частину користувачів перед повним розгортанням. Цей підхід допомагає виявити потенційні проблеми на ранньому етапі без впливу на всіх користувачів.
- **Тестування в тіні (Shadowing, Testing in Production):** Дублює живий трафік і відправляє його на нову версію мікросервісу, що працює паралельно, дозволяючи реальне тестування без впливу на користувачів у виробництві.
- **Хореографія сервісів (Service Choreography):** Децентралізує координацію між мікросервісами, дозволяючи кожному сервісу вирішувати, як реагувати на події і взаємодіяти з іншими сервісами. Цей патерн контрастує з оркестрацією, де центральний сервіс керує робочим процесом.
- **Версійований API (Versioned API):** Підтримує кілька версій API, щоб забезпечити зворотну сумісність при додаванні нових функцій або внесенні змін. Клієнти можуть вибрати, яку версію API використовувати, забезпечуючи стабільність для існуючих споживачів і дозволяючи інновації.
- **Тайм-аути та повтори (Timeouts and Retries):** Визначає часові обмеження для запитів між мікросервісами і автоматично повторює невдалі запити. Це допомагає покращити стійкість системи шляхом обробки транзитних збоїв.
- **Ідемпотентність (Idempotency):** Забезпечує, що повторне виконання запиту має той самий ефект, що й одноразове виконання, що є критично важливим у розподілених системах, де проблеми з мережею можуть призвести до дублювання запитів.
- **Віддалений виклик процедур (Remote Procedure Call, RPC):** Дозволяє мікросервісам взаємодіяти один з одним, викликаючи функції через мережу, ніби вони є локальними. Цей патерн може спростити взаємодії, але може призвести до тісного зв'язку між сервісами.
- **Композиція API (API Composition):** Об'єднує відповіді кількох мікросервісів в один вихідний результат. Цей патерн часто реалізується API-шлюзом або агрегатором сервісів для оптимізації взаємодії з клієнтами.
- **Зрештою консистентність (Eventual Consistency):** Дозволяє мікросервісам тимчасово мати неузгоджені стани, з гарантією того, що вони зрештою зійдуться до одного стану. Цей патерн є критичним у розподілених системах, де досягнення негайної консистентності є складним завданням.
- **Обмеження швидкості (Rate Limiting):** Контролює кількість запитів, які сервіс може обробити протягом певного часу. Це захищає сервіси від перевантаження надмірною кількістю запитів, особливо в публічних API.
- **Аутентифікація на основі токенів (Token-Based Authentication):** Використовує токени для аутентифікації та авторизації запитів між клієнтами та мікросервісами. Токени можуть включати облікові дані користувача, ролі або інші твердження і зазвичай видаються провайдером ідентифікації.
- **Кросс-доменне використання ресурсів (Cross-Origin Resource Sharing, CORS):** Керує тим, як веб-додатки взаємодіють з ресурсами, розміщеними на різних доменах, забезпечуючи безпечний і контрольований доступ до API з різних джерел.

## 10. Патерни Проектування для Хмари

- **Автомасштабування (Auto-Scaling):** Автоматично регулює кількість ресурсів відповідно до поточного попиту для оптимізації продуктивності та вартості.
- **Балансувальник навантаження (Load Balancer):** Розподіляє вхідний мережевий трафік між кількома серверами, щоб жоден сервер не став вузьким місцем.
- **Переривник ланцюга (Circuit Breaker):** Запобігає повторним збоям мережевого сервісу шляхом розриву з'єднання, якщо занадто багато запитів не вдається виконати за короткий час.
- **Дроселювання (Throttling):** Обмежує кількість запитів або швидкість, з якою запити обробляються, щоб захистити ресурси від перевантаження.
- **Розділення даних (Data Partitioning):** Розділяє базу даних на менші, більш керовані частини, які можуть бути розподілені між кількома серверами для покращення продуктивності.
- **Мультиоренда (Multi-Tenancy):** Підтримує кілька клієнтів (орендарів) на спільній інфраструктурі, зберігаючи їх дані ізольованими один від одного.
- **Шлюз хмарного зберігання (Cloud Storage Gateway):** Забезпечує безшовну інтеграцію між локальною інфраструктурою та хмарним зберіганням, дозволяючи переміщати дані в хмару за необхідності.
- **Хмарна черга (Cloud Queue):** Керує асинхронною обробкою завдань, розміщуючи завдання у черзі для обробки доступними ресурсами.
- **Безстанове додаток (Stateless Application):** Проектує додатки так, щоб вони не зберігали дані клієнта між запитами, що полегшує їх масштабування в хмарних середовищах.

## 11. Патерни Управління Даними

- **Реплікація даних (Data Replication):** Копіює дані між кількома системами для забезпечення доступності та надійності.
- **Шардинг даних (Data Sharding):** Розділяє великий набір даних на менші частини, які називаються шард, які можуть бути розподілені між кількома базами даних або серверами.
- **Зберігання подій (Event Sourcing):** Зберігає стан системи у вигляді послідовності подій, а не просто кінцевого стану, що дозволяє мати повну історію та аудиторські сліди.
- **CQRS (Command Query Responsibility Segregation):** Розділяє операції читання та запису в різні моделі для оптимізації продуктивності та масштабованості.
- **Майстер-слейв реплікація (Master-Slave Replication):** Основна база даних обробляє операції запису, а одна або кілька слейв-баз даних обробляють операції читання для розподілу навантаження.
- **Кешування даних (Data Cache):** Зберігає часто запитувані дані в швидкому кеші в пам'яті для покращення часу відгуку та зниження навантаження на основну базу даних.
- **Сховище даних (Data Warehousing):** Агрегує дані з кількох джерел в центральне сховище для аналізу та звітності.
- **Озеро даних (Data Lake):** Зберігає великі обсяги сирих даних у їхньому рідному форматі, зазвичай використовується для аналізу великих даних.
- **Індексація (Indexing):** Створює індекси для полів даних, щоб прискорити виконання запитів, дозволяючи швидше отримувати дані.

## 12. Патерни Інтерфейсу Користувача

- **Модель-Вид-Контролер (MVC):** Відокремлює логіку додатка, інтерфейс користувача та управління введенням у три взаємопов'язані компоненти, покращуючи модульність та легкість підтримки.
- **Модель-Вид-Модель Представлення (MVVM):** Розширює MVC, вводячи Модель Представлення, яка займається зв'язком даних між Видом та Моделлю, зазвичай використовується в сучасних фронтенд-фреймворках.
- **Спостерігач (Observer):** Дозволяє одному або кільком об'єктам спостерігати за змінами в іншому об'єкті, що часто використовується в дизайні інтерфейсу користувача для автоматичного оновлення UI при зміні даних.
- **Команда (Command):** Інкапсулює дії користувача як об'єкти, дозволяючи здійснювати дії, такі як скасування/повтор, і полегшуючи управління введенням користувача.
- **Фасад (Facade):** Забезпечує спрощений інтерфейс до складної підсистеми, що полегшує користувачам взаємодію з системою.
- **Шаблон Виду (Template View):** Визначає шаблон, що описує структуру інтерфейсу користувача, дозволяючи різним видам ділитися загальним макетом або поведінкою.
- **Адаптивний дизайн (Responsive Design):** Забезпечує, щоб інтерфейс користувача адаптувався до різних розмірів екранів і пристроїв, надаючи оптимальний досвід на всіх платформах.
- **Ліниве завантаження (Lazy Loading):** Відкладає завантаження другорядних ресурсів до тих пір, поки вони не знадобляться, покращуючи час початкового завантаження додатку.
- **Модальне вікно (Modal Window):** Використовує накладені вікна для фокусування уваги користувача на певному завданні або інформації, часто використовується для діалогів або сповіщень.
- **Нескінченний скролінг (Infinite Scroll):** Постійно завантажує новий контент у міру прокручування користувачем сторінки, покращуючи досвід користувача, уникаючи пагінації.

## Основні Принципи

### Принципи SOLID
- **Принцип Єдиної Відповідальності (SRP):** Клас повинен мати лише одну причину для зміни, що означає, що він повинен виконувати лише одне завдання.
- **Принцип Відкритості/Закритості (OCP):** Об'єкти або сутності повинні бути відкритими для розширення, але закритими для модифікації.
- **Принцип Підстановки Лісков (LSP):** Об'єкти надкласу мають бути замінними на об'єкти їх підкласів без порушення роботи програми.
- **Принцип Сегрегації Інтерфейсу (ISP):** Клієнти не повинні залежати від методів, які вони не використовують.
- **Принцип Інверсії Залежностей (DIP):** Модулі вищого рівня не повинні залежати від модулів нижчого рівня; обидва повинні залежати від абстракцій.

### Інші Основоположні Принципи
- **DRY (Не Повторюй Себе):** Заохочує до зменшення повторення в коді.
- **KISS (Роби Це Просто, Дурню):** Виступає за простоту в дизайні.
- **YAGNI (Тобі Це Не Знадобиться):** Сфокусований на додаванні функціональності тільки тоді, коли вона дійсно необхідна.
- **Закон Деметри або Принцип Найменшого Знання (LoD):** Заохочує до мінімізації знань об'єкта за межами його безпосередніх залежностей.
- **Композиція Замість Наслідування:** Віддає перевагу композиції об'єктів над наслідуванням класів для повторного використання коду.
- **Інверсія Керування (IoC):** Інверсія керування відокремлює виконання завдань від їх реалізації, передаючи контроль фреймворку або компонентам інфраструктури. Цей принцип тісно пов’язаний з принципом інверсії залежностей, оскільки передбачає використання абстракції замість конкретних реалізацій.
