# Patterns

- GRASP General Responsibility Assignment Software Patterns

- Design Patterns Gang of Four

## GRASP Principles

• Polymorphism

alternative implementations are brought to a common interface translate

Polymorphism allows handling alternative behavior options based on type and replacing system plug-in components

(Responsibilities are distributed for various behavior options using polymorphic operations for this class.)

альтернативные реализации приводятся к общему интерфейсу translate

Полиморфизм позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять подключаемые компоненты системы

(Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса.)

• Low Coupling (Низкая связность)

Если объекты в приложении сильно связаны, то любой изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает баги. Вот поэтому необходимо, чтобы код был слабо связан и зависел от абстракций.

• High Cohesion (Высокое зацепление)

относится к слабой связанности, они идут в паре и одно всегда приводит к другому. Класс должен иметь какую-то одну ответственность.

разделяй и властвуй - 1 действие

• Protected Variations (Устойчивый к изменениям)

Суть в том, чтобы определить “точки изменений” и зафиксировать их в абстракции (интерфейсе). “Точки изменений” – не что иное как наши объекты, которые могут меняться.
То есть суть принципа - определить места в системе, где поведение может измениться и выделить абстракцию, на основе которой будет происходить дальнейшее программирование с использованием этого объекта.

Необходимо обеспечить устойчивость интерфейса. Если будет много изменений связанных с объектом, он считается не устойчивым, тогда его нужно выносить в абстракцию, от которой он будет зависет

• Information Expert (Информационные эксперт)
• Creator (Создатель)
• Controller (Контроллер)
• Pure Fabrication (Чистая выдумка или чистое синтезирование)
• Indirection (Посредник)

Классификация шаблонов проектирования

Порождающие паттерны связаны с созданием экземпляров объектов; все они обеспечивают средства логической изоляции клиента от создаваемых объектов.

Паттерны, принадлежащие к поведенческой категории, соотносятся к взаимодействиям и распределению обязанностей между классами и объектами.

Структурные паттерны объединяют классы или объекты в более крупные структуры.

Базовые шаблоны:

• Delegation и Delegation Event Model
• Interface и Abstract Superclass
• Proxy или Surrogate

Заместитель – суррогат настоящего объекта. Заместитель прикидывается настоящим объектом, а на самом деле или взаимодействует с ним или просто работает «по умолчанию».
Типы заместителей:
• Удаленный заместитель. При сетевой реализации заместитель действует как представитель удаленного объекта.
• Виртуальный заместитель. Управляет доступом к ресурсу, создание которого требует больших затрат. Заместитель создает объект только тогда, когда это необходимо.
• Защитный заместитель. Контролирует доступ к ресурсу в соответствии с системой привилегий.
• Фильтрующий заместитель. Управляет доступом к группам ресурсов.
• Синхронизирующий заместитель. Обеспечивает безопасный доступ из нескольких потоков к объекту.

4 Структурные шаблоны Список структурных шаблонов:

1. Adapter
2. Decorator
3. Composite
4. Iterator
5. Bridge
6. Flyweight
7. Facade
8. Information Expert
   4.1 Адаптер (Adapter) Проблема
   Адаптер
   Декоратор объектов (Wrapper) или классов Компоновщик
   Итератор
   Мост
   Приспособленец
   Фасад
   Информационный эксперт
   Необходимо обеспечить взаимодействие несовместимых интерфейсов или создать единый устойчивый интерфейс для нескольких компонентов с разными интерфейсами.
   Решение
   Конвертировать исходный интерфейс компонента к другому виду с помощью промежуточного объекта – адаптера. Класс Адаптер реализует интерфейс, известный его клиентам. Адаптер скрывает от клиента информацию о классе, который фактически реализует выполнение интерфейса.
   Результат
   Классы клиента и адаптируемого класса являются, независимыми друг от друга Адаптер может собирать информацию о вызываемых методах
   Паттерн Адаптер преобразует интерфейс класса к другому интерфейсу, с которым работает клиент. Адаптер обеспечивает совместную работу классов, изначально невозможную из-за несовместимости интерфейсов. Адаптер связывает клиента с интерфейсом, а не с реализацией. Существует два вида адаптеров: адаптер объектов и адаптер классов.
   Все запросы адаптер делегирует адаптируемому классу Все операции с классом клиент выполняет через адаптер

Адаптер классов (требует множественного наследования)

1. Адаптер наследует интерфейс, на который рассчитывает клиент
2. Адаптер должен содержать ссылку на адаптируемый объект
3. Адаптер должен реализовать все методы интерфейса
4. Адаптер маскирует различия в семантике методов интерфейса и реального класса
   • Для этого адаптер может делегировать выполнение метода адаптируемому классу • Реализовать дополнительную логику для маскировки различий в семантике
   методов адаптируемого класса и интерфейса
   • Фактически сложность класса адаптера ничем не ограничена

4.2 Декоратор объектов или Обертка (Decorator или Wrapper)
Проблема
Необходимо возложить дополнительные обязанности (прозрачные для клиентов) на отдельный объект, а не на класс в целом. Надо имитировать интерфейс у объекта, который таким интерфейсом не обладает
Решение
Динамически добавить объекту новые обязанности, не прибегая при этом к порождению подклассов.
Результат
Большая гибкость, чем у статического наследования: можно добавлять и удалять обязанности во время выполнения программы, в то время как при использовании наследования надо было бы создавать новый класс для каждой дополнительной обязанности. Данный паттерн позволяет избежать перегруженных методами классов на верхних уровнях иерархии - новые обязанности можно добавлять по мере необходимости

Адаптер и декоратор (сравнение) Декоратор
Задача: Расширить поведение объектов или классов
Адаптер
Задача: Обеспечить взаимодействие
несовместимых интерфейсов
Включает в класс или объект новое поведение без изменения существующего кода. Интерфейс не меняется
Преобразует интерфейс к требуемому виду. Поведение не меняется
Результат: в существующий проект можно добавить новое поведение классов или объектов без изменения существующего кода декорируемых классов
Результат: можно использовать старый код классов в новом проекте или новый код классов в старом проекте

4.3 Мост (Bridge) Проблема
Требуется отделить абстракцию от реализации так, их можно было бы изменять независимо. При использовании наследования реализация жестко привязывается к абстракции, что затрудняет независимую модификацию

Решение
Поместить абстракцию и реализацию в отдельные иерархии классов
Результат
Отделение реализации от интерфейса, то есть, "Реализацию" "Абстракции" можно конфигурировать во время выполнения. Разделение классов "Абстракция" и "Реализация" устраняет зависимости от реализации, устанавливаемые на этапе компиляции: чтобы изменить класс "Реализация" не обязательно перекомпилировать класс "Абстракция".

4.4 Компоновщик (Composite)
Проблема
Необходимо обрабатывать группу или композицию структур объектов одновременно
Решение
Определить классы для композитных и атомарных объектов таким образом, чтобы они реализовывали один и тот же интерфейс
Результат
Можно реализовать иерархию объектов вида «часть-целое», чтобы клиенты единообразно обрабатывали составные и индивидуальные объекты.

Преимущества компоновщика
• Упрощает архитектуру клиента.
• Облегчает добавление новых видов компонентов.
• Способствует созданию общего дизайна.

Проблемы безопасности
• Если определить интерфейс для управления потомками в корне иерархии классов, то мы добиваемся прозрачности, так как все компоненты удается трактовать единообразно. Однако расплачиваться приходится безопасностью, поскольку клиент может попытаться выполнить бессмысленное действие, например добавить или удалить объект из листового узла;
• Если управление потомками сделать частью класса Composite, то безопасность удастся обеспечить, так как любая попытка добавить или удалить объекты из листьев будет перехвачена на этапе компиляции. Но прозрачность мы утрачиваем, ибо у листовых и составных объектов оказываются разные интерфейсы.

4.5 Приспособленец (Flyweight) Проблема
В приложении используется большое число объектов, из-за этого расходы на хранение высоки. Необходимо обеспечить поддержку множества мелких объектов.
Решение
Приспособленец, представляющий объект  а , содержит только соответствующий объекту код; конкретные значения ему хранить не надо. Клиенты передают приспособленцу всю зависящую от контекста информацию, которая нужна, чтобы он мог изобразить себя.
Результат
Уменьшается количество объектов
Условия использования
В приложении используется большое число объектов, из-за этого расходы на хранение высоки. Большую часть состояния объектов можно вынести вовне. Многие группы объектов можно заменить относительно небольшим количеством объектов, поскольку состояния объектов вынесены вовне.

Ecu cyuecrBye
flyweight[key],
вернуть его.
Иначе создать,
положить в пар
по ключу key и
вернуть

Flyweight - приспособленец
Объявляет интерфейс, с помощью которого приспособленцы могут получать внешнее состояние или как-то воздействовать на него;

Чем выше степень разделения приспособленцев, тем существеннее экономия.

4.5 Итератор (Iterator) Проблема
Необходимо обеспечить последовательную обработку элементов некоторой коллекции независимо от ее реализации
Решение
Создать класс, который возвращает следующий элемент коллекции по запросу
Результат
Обеспечен перебор элементов коллекции без раскрытия ее реализации

4.6 Фасад (Facade) Проблема
Есть сложная система, состоящая из многих взаимодействующих элементов. Необходимо упростить процесс работы с ней. Однако система должна остаться открытой для непосредственного использования.
Решение
Предоставить унифицированный интерфейс для работы с группой интерфейсов системы.
Результат
Выполнение каждой операции фасад делегирует соответствующему компоненту системы.

4.7 Информационный эксперт (Information Expert)
Проблема
В системе должна аккумулироваться, рассчитываться и т. п. необходимая информация.
Решение
Назначить обязанность аккумуляции информации, расчета и т. п. классу «информационному эксперту», обладающему необходимой информацией.
Результат
Преимущество: поддерживает инкапсуляцию, то есть объекты используют свои собственные данные для выполнения поставленных задач
Недостатки: нарушение принципа разделения обязанностей основных объектов системы, так как логика приложения и логика связи с базой данных помещаются в один класс.

(example sitemap-sitetypes but in db)

Список порождающих паттернов

1. Factory
2. Factory method
3. Abstract factory
4. Builder
5. Prototype
6. Singleton
7. Object Pool
   Простая Фабрика Фабричный метод
   Абстрактная фабрика Строитель
   Прототип Одиночка
   Пул объектов

Проблема
В программе создаются и используются объекты групп взаимосвязанных классов, причем класс объекта динамически выбирается в зависимости от выполнения некоторых условий. Появляется код типа:
if (<условие 1>) myObject = new classObj_1(...);
else if f (<условие 2>) myObject = new classObj_2(...); else if f (<условие 3>) myObject = new classObj_3(...);

5.2 Фабричный метод (Factory method) Проблема
Необходимо обеспечить создание объектов, при этом отсутствует информация о классе этого объекта.
Решение
Делегировать часть функций вспомогательному классу.

5.3 Абстрактная фабрика (Abstract factory )
Фабрика создает объекты, состоящие из нескольких составных элементов или обладающие несколькими различными свойствами.
Клиенты создают комплексные объекты или комплексные свойства объектов, пользуясь исключительно интерфейсом AbstractFactory. Клиентам ничего не известно о классах, реализующих объекты конкретного типа.

Преимущества
Абстрактная фабрика инкапсулирует ответственность за создание классов и процесс их создания, следовательно, она изолирует клиента от деталей реализации классов. Простая замена Абстрактной фабрики, т.к. она используется в приложении только один раз при инстанцировании.
Недостатки
Интерфейс Абстрактной фабрики фиксирует набор объектов, которые можно создать. Расширение Абстрактной фабрики для изготовления новых объектов часто затруднительно.

5.3 Прототип (Prototype)
Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

5.4 Строитель (Builder) Проблема
Необходимо целиком создать новый объект с помощью своих операций для добавления конструктивных элементов. Можно изменять типы частей формируемого объекта или изменять способ его построения.
Результат
Отделили конструирование сложного объекта от его представления, так что в результате
64
одного и того же процесса конструирования могут получаться разные представления.

5.5 Одиночка (Singleton) Проблема
Необходимо, чтобы у класса существовал только один экземпляр, к которому нужно создать глобальную точку доступа.
Результат
Сам класс контролирует то, что у него есть только один экземпляр, может запретить создание дополнительных экземпляров, перехватывая запросы на создание новых объектов, и он же способен предоставить доступ к своему экземпляру.

5.6 Пул объектов (Object Pool)
Проблема
Создание объекта требует больших затрат или может быть создано только ограниченное количество объектов некоторого класса.
Решение
Желательно, чтобы все многократно используемые объекты, свободные в некоторый момент времени, хранились в одном и том же пуле объектов. Тогда ими можно управлять на основе единой политики. Для этого класс Object Pool проектируется с помощью паттерна Singleton. Если у нас много однотипных объектов, создание и уничтожение которых занимает много ресурсов, удобно использовать этот паттерн.
Пулы объектов (известны также как пулы ресурсов) используются для управления кэшированием объектов.
